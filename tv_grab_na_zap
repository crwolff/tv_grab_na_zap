#!/usr/bin/python2
################################################################################
#   This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

import appdirs
import argparse
import base64
import calendar
import datetime
import errno
import gzip
import hashlib
import json
import logging
import logging.handlers
import os
import re
from shutil import copyfile
import _strptime
import sys
import time
import urllib2
from collections import OrderedDict

# Utility to create directory
def mkdir_p(path):
    try:
	os.makedirs(path)
    except OSError as exc:
	if exc.errno == errno.EEXIST and os.path.isdir(path):
	    pass
	else:
	    raise

# Main scraper
def mainRun( days, offset, config_file, output ):

    def deleteOldCache(oldestTime, showList):
        logging.info('Checking for old cache files...')
        try:
            if os.path.exists(cacheDir):
                entries = os.listdir(cacheDir)
                for entry in entries:
                    oldfile = entry.split('.')[0]
                    if oldfile.isdigit():
                        fn = os.path.join(cacheDir, entry)
                        if (int(oldfile) <= oldestTime):
                            try:
                                os.remove(fn)
                                logging.info('Deleting old cache: %s', entry)
                            except OSError, e:
                                logging.warn('Error Deleting: %s - %s.' % (e.filename, e.strerror))
                    elif not oldfile.isdigit():
                        fn = os.path.join(cacheDir, entry)
                        if os.path.getmtime( fn ) < oldestTime:
                            try:
                                os.remove(fn)
                                logging.info('Deleting old cache: %s', entry)
                            except OSError, e:
                                logging.warn('Error Deleting: %s - %s.' % (e.filename, e.strerror))
        except Exception as e:
            logging.exception('Exception: deleteOldCache - %s', e.strerror)

    def convTime(t):
        return time.strftime("%Y%m%d%H%M%S",time.localtime(int(t)))

    def savepage(fn, data):
        if not os.path.exists(cacheDir):
            os.mkdir(cacheDir)
        fileDir = os.path.join(cacheDir, fn)
        with gzip.open(fileDir,"wb+") as f:
            f.write(data)
            f.close()

    def genreSort(EPfilter, EPgenre):
        genreList = []
        if epgenre == '2':
            # for f in EPfilter:
            #     fClean = re.sub('filter-','',f)
            #     genreList.append(fClean)
            for g in EPgenre:
                if g != "Comedy":
                    genreList.append(g)
            if 'Movie' in genreList or 'movie' in genreList or 'Movies' in genreList:
                genreList.insert(0, "Movie / Drama")
            if 'News' in genreList:
                genreList.insert(0, "News / Current affairs")
            if 'Game show' in genreList:
                genreList.insert(0, "Game show / Quiz / Contest")
            if 'Law' in genreList:
                genreList.insert(0, "Show / Game show")
            if 'Art' in genreList or 'Culture' in genreList:
                genreList.insert(0, "Arts / Culture (without music)")
            if 'Entertainment' in genreList:
                genreList.insert(0, "Popular culture / Traditional Arts")
            if 'Politics' in genreList or 'Social' in genreList or 'Public affairs' in genreList:
                genreList.insert(0, "Social / Political issues / Economics")
            if 'Education' in genreList or 'Science' in genreList:
                genreList.insert(0, "Education / Science / Factual topics")
            if 'How-to' in genreList:
                genreList.insert(0, "Leisure hobbies")
            if 'Travel' in genreList:
                genreList.insert(0, "Tourism / Travel")
            if 'Sitcom' in genreList:
                genreList.insert(0, "Variety show")
            if 'Talk' in genreList:
                genreList.insert(0, "Talk show")
            if 'Children' in genreList:
                genreList.insert(0, "Children's / Youth programs")
            if 'Animated' in genreList:
                genreList.insert(0, "Cartoons / Puppets")
            if 'Music' in genreList:
                genreList.insert(0, "Music / Ballet / Dance")
        if epgenre == '1':
            # for f in EPfilter:
            #     fClean = re.sub('filter-','',f)
            #     genreList.append(fClean)
            for g in EPgenre:
                genreList.append(g)
            if 'Movie' in genreList or 'movie' in genreList or 'Movies' in genreList:
                genreList = ["Movie / Drama"]
            elif 'News' in genreList:
                genreList = ["News / Current affairs"]
            elif 'News magazine' in genreList:
                genreList = ["News magazine"]
            elif 'Public affairs' in genreList:
                genreList = ["News / Current affairs"]
            elif 'Interview' in genreList:
                genreList = ["Discussion / Interview / Debate"]
            elif 'Game show' in genreList:
                genreList = ["Game show / Quiz / Contest"]
            elif 'Talk' in genreList:
                genreList = ["Talk show"]
            elif 'Sports' in genreList:
                genreList = ["Sports"]
            elif 'Sitcom' in genreList:
                genreList = ["Variety show"]
            elif 'Children' in genreList:
                genreList = ["Children's / Youth programs"]
            else:
                genreList = ["Variety show"]
        if epgenre == '3':
            # for f in EPfilter:
            #     fClean = re.sub('filter-','',f)
            #     genreList.append(fClean)
            for g in EPgenre:
                genreList.append(g)
        if 'Movie' in genreList:
            genreList.remove('Movie')
            genreList.insert(0, 'Movie')
        return genreList

    def encwrite(fh, enc, line):
	fh.write( line.encode(enc) )

    def printHeader(fh, enc):
        logging.info('Creating xmltv.xml file...')
        encwrite(fh, enc,"<?xml version=\"1.0\" encoding=\""+ enc + "\"?>\n")
        encwrite(fh, enc,"<!DOCTYPE tv SYSTEM \"xmltv.dtd\">\n\n")
        encwrite(fh, enc,"<tv source-info-url=\"http://tvschedule.zap2it.com/\" source-info-name=\"zap2it.com\">\n")

    def printFooter(fh, enc):
        encwrite(fh, enc,"</tv>\n")

    def printStations(fh, enc):
        global stationCount
        stationCount = 0
        try:
            logging.info('Writing Stations to xmltv.xml file...')
            try:
                scheduleSort = OrderedDict(sorted(schedule.iteritems(), key=lambda x: int(x[1]['chnum'])))
            except:
                scheduleSort = OrderedDict(sorted(schedule.iteritems(), key=lambda x: x[1]['chfcc']))
            for station in scheduleSort:
                encwrite(fh, enc,'\t<channel id=\"' + station + '.zap2epg\">\n')
                if 'chtvh' in scheduleSort[station] and scheduleSort[station]['chtvh'] is not None:
                    xchtvh = re.sub('&','&amp;',scheduleSort[station]['chtvh'])
                    encwrite(fh, enc,'\t\t<display-name>' + xchtvh + '</display-name>\n')
                if 'chnum' in scheduleSort[station] and 'chfcc' in scheduleSort[station]:
                    xchnum = scheduleSort[station]['chnum']
                    xchfcc = scheduleSort[station]['chfcc']
                    encwrite(fh, enc,'\t\t<display-name>' + xchnum + ' ' + re.sub('&','&amp;',xchfcc) + '</display-name>\n')
                    encwrite(fh, enc,'\t\t<display-name>' + re.sub('&','&amp;',xchfcc) + '</display-name>\n')
                    encwrite(fh, enc,'\t\t<display-name>' + xchnum + '</display-name>\n')
                elif 'chfcc' in scheduleSort[station]:
                    xchnum = scheduleSort[station]['chfcc']
                    encwrite(fh, enc,'\t\t<display-name>' + re.sub('&','&amp;',xcfcc) + '</display-name>\n')
                elif 'chnum' in scheduleSort[station]:
                    xchnum = scheduleSort[station]['chnum']
                    encwrite(fh, enc,'\t\t<display-name>' + xchnum + '</display-name>\n')
                if 'chicon' in scheduleSort[station]:
                    encwrite(fh, enc,"\t\t<icon src=\"http:" + scheduleSort[station]['chicon'] + "\" />\n")
                encwrite(fh, enc,"\t</channel>\n")
                stationCount += 1
        except Exception as e:
            logging.exception('Exception: printStations')

    def printEpisodes(fh, enc):
        global episodeCount
        episodeCount = 0
        try:
            logging.info('Writing Episodes to xmltv.xml file...')
            if xdesc is True:
                logging.info('Appending Xdetails to description for xmltv.xml file...')
            for station in schedule:
                lang = 'en'
                sdict = schedule[station]
                for episode in sdict:
                    if not episode.startswith("ch"):
                        try:
                            edict = sdict[episode]
                            if 'epstart' in edict:
                                startTime = convTime(edict['epstart'])
                                is_dst = time.daylight and time.localtime().tm_isdst > 0
                                TZoffset = "%.2d%.2d" %(- (time.altzone if is_dst else time.timezone)/3600, 0)
                                stopTime = convTime(edict['epend'])
                                encwrite(fh, enc,'\t<programme start=\"' + startTime + ' ' + TZoffset + '\" stop=\"' + stopTime + ' ' + TZoffset + '\" channel=\"' + station + '.zap2epg' + '\">\n')
                                dd_progid = edict['epid']
                                if edict['epshow'] is not None:
                                    encwrite(fh, enc,'\t\t<title lang=\"' + lang + '\">' + re.sub('&','&amp;',edict['epshow']) + '</title>\n')
				else:
                                    encwrite(fh, enc,'\t\t<title lang=\"' + lang + '\">TBA</title>\n')
                                if edict['eptitle'] is not None:
                                    encwrite(fh, enc,'\t\t<sub-title lang=\"'+ lang + '\">' + re.sub('&','&amp;', edict['eptitle']) + '</sub-title>\n')
                                if xdesc == 'true':
                                    xdescSort = addXDetails(edict)
                                    encwrite(fh, enc,'\t\t<desc lang=\"' + lang + '\">' + re.sub('&','&amp;', xdescSort) + '</desc>\n')
                                if xdesc == 'false':
                                    if edict['epdesc'] is not None:
                                        encwrite(fh, enc,'\t\t<desc lang=\"' + lang + '\">' + re.sub('&','&amp;', edict['epdesc']) + '</desc>\n')
                                # <credits />
                                if edict['epyear'] is not None:
                                    encwrite(fh, enc,'\t\t<date>' + edict['epyear'] + '</date>\n')
                                if epgenre != '0':
                                    if edict['epfilter'] is not None and edict['epgenres'] is not None:
                                        genreNewList = genreSort(edict['epfilter'], edict['epgenres'])
                                        for genre in genreNewList:
                                            if ( genre is not None ) and ( genre != '' ):
                                                encwrite(fh, enc,"\t\t<category lang=\"" + lang + "\">" + genre + "</category>\n")
                                # <keyword />
                                # <language />
                                # <orig-language />
                                # <length />
                                if not episode.startswith("MV"):
                                    if epicon == '1':
                                        if edict['epimage'] is not None and edict['epimage'] != '':
                                            encwrite(fh, enc,'\t\t<icon src="https://zap2it.tmsimg.com/assets/' + edict['epimage'] + '.jpg" />\n')
                                        else:
                                            if edict['epthumb'] is not None and edict['epthumb'] != '':
                                                encwrite(fh, enc,'\t\t<icon src="https://zap2it.tmsimg.com/assets/' + edict['epthumb'] + '.jpg" />\n')
                                    if epicon == '2':
                                        if edict['epthumb'] is not None and edict['epthumb'] != '':
                                            encwrite(fh, enc,'\t\t<icon src="https://zap2it.tmsimg.com/assets/' + edict['epthumb'] + '.jpg" />\n')
                                if episode.startswith("MV"):
                                    if edict['epthumb'] is not None and edict['epthumb'] != '':
                                        encwrite(fh, enc,'\t\t<icon src="https://zap2it.tmsimg.com/assets/' + edict['epthumb'] + '.jpg" />\n')
                                # <url />
                                # <country />
                                encwrite(fh, enc,'\t\t<episode-num system=\"dd_progid\">' + dd_progid[:-4] + '.' + dd_progid[-4:] + '</episode-num>\n')
                                if edict['epsn'] is not None and edict['epen'] is not None:
                                    encwrite(fh, enc,"\t\t<episode-num system=\"onscreen\">" + 'S' + edict['epsn'].zfill(2) + 'E' + edict['epen'].zfill(2) + "</episode-num>\n")
                                    encwrite(fh, enc,"\t\t<episode-num system=\"xmltv_ns\">" + str(int(edict['epsn'])-1) +  "." + str(int(edict['epen'])-1) + ".</episode-num>\n")
                                # <video />
                                # <audio />
                                if not any(i in ['New', 'Live'] for i in edict['epflag']):
                                    if edict['epoad'] is not None and int(edict['epoad']) > 0:
                                        encwrite(fh, enc,"\t\t<previously-shown ")
                                        encwrite(fh, enc,"start=\"" + convTime(edict['epoad']) + " " + TZoffset + "\"")
                                        encwrite(fh, enc," />\n")
                                # <premiere />
                                # <last-chance />
                                if edict['epflag'] is not None:
                                    if 'New' in edict['epflag']:
                                        encwrite(fh, enc,"\t\t<new />\n")
                                # <subtitles />
                                if edict['eprating'] is not None:
                                    encwrite(fh, enc,'\t\t<rating>\n\t\t\t<value>' + edict['eprating'] + '</value>\n\t\t</rating>\n')
                                if edict['epstar'] is not None:
                                    encwrite(fh, enc,'\t\t<star-rating>\n\t\t\t<value>' + edict['epstar'] + '/4</value>\n\t\t</star-rating>\n')
                                # <review />
                                encwrite(fh, enc,"\t</programme>\n")
                                episodeCount += 1
                        except Exception as e:
                            logging.exception('No data for episode %s:', episode)
                            #fn = os.path.join(cacheDir, episode + '.json')
                            #os.remove(fn)
                            #logging.info('Deleting episode %s:', episode)
        except Exception as e:
            logging.exception('Exception: printEpisodes')

    def xmltv( outFile ):
        try:
            enc = 'utf-8'
            if outFile is None:
                fh = sys.stdout
            else:
                fh = open(outFile, 'w+b')
            printHeader(fh, enc)
            printStations(fh, enc)
            printEpisodes(fh, enc)
            printFooter(fh, enc)
            if outFile is not None:
                fh.close()
        except Exception as e:
            logging.exception('Exception: xmltv')

    def parseStations(content):
        try:
            ch_guide = json.loads(content)
            for station in ch_guide['channels']:
                skey = station.get('channelId')
                if stationList is not None:
                    if skey in stationList:
                        schedule[skey] = {}
                        chName = station.get('callSign')
                        schedule[skey]['chfcc'] = chName
                        schedule[skey]['chicon'] = station.get('thumbnail').split('?')[0]
                        chnumStart = station.get('channelNo')
                        if '.' not in chnumStart and chmatch == 'true' and chName is not None:
                            chsub = re.search('(\d+)$', chName)
                            if chsub is not None:
                                chnumUpdate = chnumStart + '.' + chsub.group(0)
                            else:
                                chnumUpdate = chnumStart + '.1'
                        else:
                            chnumUpdate = chnumStart
                        schedule[skey]['chnum'] = chnumUpdate
                else:
                    schedule[skey] = {}
                    chName = station.get('callSign')
                    schedule[skey]['chfcc'] = chName
                    schedule[skey]['chicon'] = station.get('thumbnail').split('?')[0]
                    chnumStart = station.get('channelNo')
                    if '.' not in chnumStart and chmatch == 'true' and chName is not None:
                        chsub = re.search('(\d+)$', chName)
                        if chsub is not None:
                            chnumUpdate = chnumStart + '.' + chsub.group(0)
                        else:
                            chnumUpdate = chnumStart + '.1'
                    else:
                        chnumUpdate = chnumStart
                    schedule[skey]['chnum'] = chnumUpdate
        except Exception as e:
            logging.exception('Exception: parseStations')

    def parseEpisodes(content):
        CheckTBA = "Safe"
        try:
            ch_guide = json.loads(content)
            for station in ch_guide['channels']:
                skey = station.get('channelId')
                if stationList is not None:
                    if skey in stationList:
                        episodes = station.get('events')
                        for episode in episodes:
                            epkey = str(calendar.timegm(time.strptime(episode.get('startTime'), '%Y-%m-%dT%H:%M:%SZ')))
                            schedule[skey][epkey] = {}
                            schedule[skey][epkey]['epid'] = episode['program'].get('tmsId')
                            schedule[skey][epkey]['epstart'] = str(calendar.timegm(time.strptime(episode.get('startTime'), '%Y-%m-%dT%H:%M:%SZ')))
                            schedule[skey][epkey]['epend'] = str(calendar.timegm(time.strptime(episode.get('endTime'), '%Y-%m-%dT%H:%M:%SZ')))
                            schedule[skey][epkey]['eplength'] = episode.get('duration')
                            schedule[skey][epkey]['epshow'] = episode['program'].get('title')
                            schedule[skey][epkey]['eptitle'] = episode['program'].get('episodeTitle')
                            schedule[skey][epkey]['epdesc'] = episode['program'].get('shortDesc')
                            schedule[skey][epkey]['epyear'] = episode['program'].get('releaseYear')
                            schedule[skey][epkey]['eprating'] = episode.get('rating')
                            schedule[skey][epkey]['epflag'] = episode.get('flag')
                            schedule[skey][epkey]['eptags'] = episode.get('tags')
                            schedule[skey][epkey]['epsn'] = episode['program'].get('season')
                            schedule[skey][epkey]['epen'] = episode['program'].get('episode')
                            schedule[skey][epkey]['epthumb'] = episode.get('thumbnail')
                            schedule[skey][epkey]['epoad'] = None
                            schedule[skey][epkey]['epstar'] = None
                            schedule[skey][epkey]['epfilter'] = episode.get('filter')
                            schedule[skey][epkey]['epgenres'] = None
                            schedule[skey][epkey]['epcredits'] = None
                            schedule[skey][epkey]['epxdesc'] = None
                            schedule[skey][epkey]['epseries'] = episode.get('seriesId')
                            schedule[skey][epkey]['epimage'] = None
                            schedule[skey][epkey]['epfan'] = None
                            if "TBA" in schedule[skey][epkey]['epshow']:
                                CheckTBA = "Unsafe"
                            elif schedule[skey][epkey]['eptitle']:
                                if "TBA" in schedule[skey][epkey]['eptitle']:
                                    CheckTBA = "Unsafe"
                else:
                    episodes = station.get('events')
                    for episode in episodes:
                        epkey = str(calendar.timegm(time.strptime(episode.get('startTime'), '%Y-%m-%dT%H:%M:%SZ')))
                        schedule[skey][epkey] = {}
                        schedule[skey][epkey]['epid'] = episode['program'].get('tmsId')
                        schedule[skey][epkey]['epstart'] = str(calendar.timegm(time.strptime(episode.get('startTime'), '%Y-%m-%dT%H:%M:%SZ')))
                        schedule[skey][epkey]['epend'] = str(calendar.timegm(time.strptime(episode.get('endTime'), '%Y-%m-%dT%H:%M:%SZ')))
                        schedule[skey][epkey]['eplength'] = episode.get('duration')
                        schedule[skey][epkey]['epshow'] = episode['program'].get('title')
                        schedule[skey][epkey]['eptitle'] = episode['program'].get('episodeTitle')
                        schedule[skey][epkey]['epdesc'] = episode['program'].get('shortDesc')
                        schedule[skey][epkey]['epyear'] = episode['program'].get('releaseYear')
                        schedule[skey][epkey]['eprating'] = episode.get('rating')
                        schedule[skey][epkey]['epflag'] = episode.get('flag')
                        schedule[skey][epkey]['eptags'] = episode.get('tags')
                        schedule[skey][epkey]['epsn'] = episode['program'].get('season')
                        schedule[skey][epkey]['epen'] = episode['program'].get('episode')
                        schedule[skey][epkey]['epthumb'] = episode.get('thumbnail')
                        schedule[skey][epkey]['epoad'] = None
                        schedule[skey][epkey]['epstar'] = None
                        schedule[skey][epkey]['epfilter'] = episode.get('filter')
                        schedule[skey][epkey]['epgenres'] = None
                        schedule[skey][epkey]['epcredits'] = None
                        schedule[skey][epkey]['epxdesc'] = None
                        schedule[skey][epkey]['epseries'] = episode.get('seriesId')
                        schedule[skey][epkey]['epimage'] = None
                        schedule[skey][epkey]['epfan'] = None
                        if "TBA" in schedule[skey][epkey]['epshow']:
                            CheckTBA = "Unsafe"
                        elif schedule[skey][epkey]['eptitle']:
                            if "TBA" in schedule[skey][epkey]['eptitle']:
                                CheckTBA = "Unsafe"
        except Exception as e:
            logging.exception('Exception: parseEpisodes')
        return CheckTBA

    def parseXdetails():
        showList = []
        failList = []
        try:
            for station in schedule:
                sdict = schedule[station]
                for episode in sdict:
                    if not episode.startswith("ch"):
                        edict = sdict[episode]
                        EPseries = edict['epseries']
                        showList.append(edict['epseries'])
                        filename = EPseries + '.json'
                        fileDir = os.path.join(cacheDir, filename)
                        try:
                            if not os.path.exists(fileDir) and EPseries not in failList:
                                retry = 3
                                while retry > 0:
                                    logging.info('Downloading details data for: %s', EPseries)
                                    url = 'https://tvlistings.gracenote.com/api/program/overviewDetails'
                                    data = 'programSeriesID=' + EPseries
                                    try:
                                        URLcontent = urllib2.Request(url, data=data)
                                        JSONcontent = urllib2.urlopen(URLcontent).read()
                                        if JSONcontent:
                                            with open(fileDir,"wb+") as f:
                                                f.write(JSONcontent)
                                                f.close()
                                            retry = 0
                                        else:
                                            time.sleep(1)
                                            retry -= 1
                                            logging.warn('Retry downloading missing details data for: %s', EPseries)
                                    except urllib2.URLError, e:
                                        time.sleep(1)
                                        retry -= 1
                                        logging.warn('Retry downloading details data for: %s  -  %s', EPseries, e)
                            if os.path.exists(fileDir):
                                fileSize = os.path.getsize(fileDir)
                                if fileSize > 0:
				    os.utime(fileDir, None)
                                    with open(fileDir, 'rb') as f:
                                        EPdetails = json.loads(f.read())
                                        f.close()
                                    logging.info('Parsing %s', filename)
                                    edict['epimage'] = EPdetails.get('seriesImage')
                                    edict['epfan'] = EPdetails.get('backgroundImage')
                                    EPgenres = EPdetails.get('seriesGenres')
                                    if filename.startswith("MV"):
                                        edict['epcredits'] = EPdetails['overviewTab'].get('cast')
                                        EPgenres = 'Movie|' + EPgenres
                                    edict['epgenres'] = EPgenres.split('|')
                                    #edict['epstar'] = EPdetails.get('starRating')
                                    EPlist = EPdetails['upcomingEpisodeTab']
                                    EPid = edict['epid']
                                    for airing in EPlist:
                                        if airing.get('tmsID') and EPid.lower() == airing['tmsID'].lower():
                                            if not episode.startswith("MV"):
                                                try:
                                                    origDate = airing.get('originalAirDate')
                                                    if origDate != '':
                                                        EPoad = re.sub('Z', ':00Z', airing.get('originalAirDate'))
                                                        edict['epoad'] = str(calendar.timegm(time.strptime(EPoad, '%Y-%m-%dT%H:%M:%SZ')))
                                                except Exception as e:
                                                    logging.exception('Could not parse oad for: %s - %s', episode, e)
                                                try:
                                                    TBAcheck = airing.get('episodeTitle')
                                                    if TBAcheck != '':
                                                        if "TBA" in TBAcheck:
                                                            try:
                                                                os.remove(fileDir)
                                                                logging.info('Deleting %s due to TBA listings', filename)
                                                                showList.remove(edict['epseries'])
                                                            except OSError, e:
                                                                logging.warn('Error Deleting: %s - %s.' % (e.filename, e.strerror))
                                                except Exception as e:
                                                    logging.exception('Could not parse TBAcheck for: %s - %s', episode, e)
                                else:
                                    logging.warn('Could not parse data for: %s - deleting file', filename)
                                    os.remove(fileDir)
                            else:
                                logging.warn('Could not download details data for: %s - skipping episode', episode)
                                failList.append(EPseries)
                        except Exception as e:
                            logging.exception('Could not parse data for: %s - deleting file  -  %s', episode, e)
                            #os.remove(fileDir)
        except Exception as e:
            logging.exception('Exception: parseXdetails')
        return showList

    def addXDetails(edict):
        try:
            ratings = ""
            date = ""
            myear = ""
            new = ""
            live = ""
            hd = ""
            cc = ""
            cast = ""
            season = ""
            epis = ""
            episqts = ""
            prog = ""
            plot= ""
            descsort = ""
            bullet = u"\u2022 "
            hyphen = u"\u2013 "
            newLine = "\n"
            space = " "
            colon = u"\u003A "
            vbar = u"\u007C "
            slash = u"\u2215 "
            comma = u"\u002C "

            def getSortName(opt):
                return {
                    1: bullet,
                    2: newLine,
                    3: hyphen,
                    4: space,
                    5: colon,
                    6: vbar,
                    7: slash,
                    8: comma,
                    9: plot,
                    10: new,
                    11: hd,
                    12: cc,
                    13: season,
                    14: ratings,
                    15: date,
                    16: prog,
                    17: epis,
                    18: episqts,
                    19: cast,
                    20: myear,
                }.get(opt, None)

            def cleanSortList(optList):
                cleanList=[]
                optLen = len(optList)
                for opt in optList:
                    thisOption = getSortName(int(opt))
                    if thisOption:
                        cleanList.append(int(opt))
                for item in reversed(cleanList):
                    if cleanList[-1] <= 8:
                        del cleanList[-1]
                return cleanList

            def makeDescsortList(optList):
                sortOrderList =[]
                lastOption = 1
                cleanedList = cleanSortList(optList)
                for opt in cleanedList:
                    thisOption = getSortName(int(opt))
                    if int(opt) <= 8 and lastOption <= 8:
                        if int(opt) == 2 and len(sortOrderList) > 1:
                            del sortOrderList[-1]
                            sortOrderList.append(thisOption)
                        lastOption = int(opt)
                    elif thisOption and lastOption:
                        sortOrderList.append(thisOption)
                        lastOption = int(opt)
                    elif thisOption:
                        lastOption = int(opt)
                return sortOrderList

            if edict['epoad'] is not None and int(edict['epoad']) > 0:
                is_dst = time.daylight and time.localtime().tm_isdst > 0
                TZoffset = (time.altzone if is_dst else time.timezone)
                origDate = int(edict['epoad']) + TZoffset
                finalDate = datetime.datetime.fromtimestamp(origDate).strftime('%B %d%% %Y')
                finalDate = re.sub('%', ',', finalDate)
                date = "First aired: " + finalDate + space
            if edict['epyear'] is not None:
                myear = "Released: " + edict['epyear'] + space
            if edict['eprating'] is not None:
                ratings = edict['eprating'] + space
            if edict['epflag'] != []:
                flagList = edict['epflag']
                new = ' - '.join(flagList).upper() + space
            #if edict['epnew'] is not None:
                #new = edict['epnew'] + space
            #if edict['eplive'] is not None:
                #new = edict['eplive'] + space
            #if edict['epprem'] is not None:
                #new = edict['epprem'] + space
            #if edict['epfin'] is not None:
                #new = edict['epfin'] + space
            if edict['eptags'] != []:
                tagsList = edict['eptags']
                cc = ' | '.join(tagsList).upper() + space
            #if edict['ephd'] is not None:
                #hd = edict['ephd'] + space
            if edict['epsn'] is not None and edict['epen'] is not None:
                s = re.sub('S', '', edict['epsn'])
                sf = "Season " + str(int(s))
                e = re.sub('E', '', edict['epen'])
                ef = "Episode " + str(int(e))
                season = sf + " - " + ef + space
            if edict['epcredits'] is not None:
                cast = "Cast: "
                castlist = ""
                prev = None
                EPcastList = []
                for c in edict['epcredits']:
                    EPcastList.append(c['name'])
                for g in EPcastList:
                    if prev is None:
                        castlist = g
                        prev = g
                    else:
                        castlist = castlist + ", " + g
                cast = cast + castlist + space
            if edict['epshow'] is not None:
                prog = edict['epshow'] + space
            if edict['eptitle'] is not None:
                epis = edict['eptitle'] + space
                episqts = '\"' + edict['eptitle'] + '\"' + space
            if edict['epdesc'] is not None:
                plot = edict['epdesc'] + space

        # todo - handle star ratings

            descsort = "".join(makeDescsortList(xdescOrder))
            return descsort
        except Exception as e:
            logging.exception('Exception: addXdetails to description')

    # Load settings
    settingsDict = {}
    stationList = []
    with open(config_file,'r') as fp:
	for line in fp:
	    parts = re.sub( ' *[#;].*\n','', line ).strip().split('=',1)
	    parts = map( str.strip, parts )
	    if (( parts[0] == '' ) or ( len(parts) != 2 )):
		pass
	    elif ( parts[0] == 'channel' ):
		stationList.append( re.sub( '.zap2epg', '', parts[1] ))
	    else:
		settingsDict[parts[0]] = parts[1]
	#print settingsDict
    for setting in settingsDict:
        if setting == 'country':
            country = settingsDict[setting]
        if setting == 'zipcode':
            zipcode = settingsDict[setting]
        if setting == 'lineup':
            lineup = settingsDict[setting]
        if setting == 'lineupcode':
            lineupcode = settingsDict[setting]
        if setting == 'device':
            device = settingsDict[setting]
        if setting == 'xdetails':
            xdetails = settingsDict[setting]
        if setting == 'xdesc':
            tmp = settingsDict[setting]
	    xdesc = tmp[0]
	    xdescOrder = tmp.split(',')[1:]
        if setting == 'epicon':
            epicon = settingsDict[setting]
        if setting == 'epgenre':
            epgenre = settingsDict[setting]
        if setting == 'chmatch':
            chmatch = settingsDict[setting]
    if lineupcode != 'lineupId':
        chmatch = 'false'
    logging.info('Running tv_grab_na_zap --offset %d --days %d for zipcode: %s and lineup: %s', offset, days, zipcode, lineup)
    pythonStartTime = time.time()
    dayHours = int(days) * 8 # each grid chunk is 3 hours, 8 in a day
    gridtimeStart = (int(time.mktime(time.strptime(str(datetime.datetime.combine(datetime.datetime.now(), datetime.time.min) + datetime.timedelta(days=int(offset))), '%Y-%m-%d %H:%M:%S'))))
    schedule = {}

    try:
        if not os.path.exists(cacheDir):
            os.mkdir(cacheDir)
        count = 0
        gridtime = gridtimeStart
        if stationList is None:
            logging.info('No channel list found - adding all stations!')
        while count < dayHours:
            filename = str(gridtime) + '.json.gz'
            fileDir = os.path.join(cacheDir, filename)
            if ((offset <= 0) and (count < 8)) or (not os.path.exists(fileDir)):
                try:
                    logging.info('Downloading guide data for: %s', str(gridtime))
                    url = 'http://tvlistings.gracenote.com/api/grid?lineupId=&timespan=3&headendId=' + lineupcode + '&country=' + country + '&device=' + device + '&postalCode=' + zipcode + '&time=' + str(gridtime) + '&pref=-&userId=-'
                    saveContent = urllib2.urlopen(url).read()
                    savepage(fileDir, saveContent)
                except:
                    logging.warn('Could not download guide data for: %s', str(gridtime))
                    logging.warn('URL: %s', url)
		    sys.stderr.write("No data available\n")
		    exit(1)
            if os.path.exists(fileDir):
                try:
                    with gzip.open(fileDir, 'rb') as f:
                        content = f.read()
                        f.close()
                    logging.info('Parsing %s', filename)
                    if count == 0:
                        parseStations(content)
                    TBAcheck = parseEpisodes(content)
                    if TBAcheck == "Unsafe":
                        try:
                            os.remove(fileDir)
                            logging.info('Deleting %s due to TBA listings', filename)
                        except OSError, e:
                            logging.warn('Error Deleting: %s - %s.' % (e.filename, e.strerror))
                except:
                    logging.warn('JSON file error for: %s - deleting file', filename)
                    os.remove(fileDir)
            count += 1
            gridtime = gridtime + 10800
        if xdetails == 'true':
            showList = parseXdetails()
        else:
            showList = []
        xmltv( output )
	# Delete cache data prior to 3 days ago
	oldestTime = (int(time.mktime(time.strptime(str(datetime.datetime.combine(datetime.datetime.now(), datetime.time.min) + datetime.timedelta(days=int(-3))), '%Y-%m-%d %H:%M:%S'))))
        deleteOldCache(oldestTime, showList)
        timeRun = round((time.time() - pythonStartTime),2)
        logging.info('zap2epg completed in %s seconds. ', timeRun)
        logging.info('%s Stations and %s Episodes written to xmltv.xml file.', str(stationCount), str(episodeCount))
        return timeRun, stationCount, episodeCount
    except Exception as e:
        logging.exception('Exception: main')

# Manual configuration
def configure(filename):
    # Pick country
    sys.stdout.write( 'Country (USA/CAN): ' )
    sys.stdout.flush()
    country = sys.stdin.readline().strip()
    country = country.upper()
    if (( country != 'USA' ) and ( country != 'CAN' )):
	print 'Invalid country, must be USA or CAN ({})'.format(country)
	return

    # Pick zipcode
    sys.stdout.write( 'Zipcode: ' )
    sys.stdout.flush()
    zipcode = sys.stdin.readline().strip()
    if ( country == 'USA' ) and ( zipcode.isdigit() == False ):
	print 'USA zipcode must be numeric'
	return
    elif ( country == 'CAN' ):
	zipcode = re.sub(' ', '', zipcode.upper())

    # Download lineu
    url = 'https://tvlistings.gracenote.com/gapzap_webapi/api/Providers/getPostalCodeProviders/' + country + '/' + zipcode + '/gapzap'
    if ( country == 'USA' ):
	lineupsN = ['AVAILABLE LINEUPS', 'TIMEZONE - Eastern', 'TIMEZONE - Central', 'TIMEZONE - Mountain', 'TIMEZONE - Pacific', 'TIMEZONE - Alaskan', 'TIMEZONE - Hawaiian']
	lineupsC = ['NONE', 'DFLTE', 'DFLTC', 'DFLTM', 'DFLTP', 'DFLTA', 'DFLTH']
	deviceX = ['-', '-', '-', '-', '-', '-', '-']
    else:
	lineupsN = ['AVAILABLE LINEUPS', 'TIMEZONE - Eastern', 'TIMEZONE - Central', 'TIMEZONE - Mountain', 'TIMEZONE - Pacific']
	lineupsC = ['NONE', 'DFLTEC', 'DFLTCC', 'DFLTMC', 'DFLTPC']
	deviceX = ['-', '-', '-', '-', '-']
    content = urllib2.urlopen(url).read()
    lineupDict = json.loads(content)
    #print lineupDict

    # Parse providers
    if 'Providers' in lineupDict:
	for provider in lineupDict['Providers']:
	    lineupName = provider.get('name')
	    lineupLocation = provider.get('location')
	    if lineupLocation != '':
		lineupCombo = lineupName + '  (' + lineupLocation + ')'
		lineupsN.append(lineupCombo)
	    else:
		lineupsN.append(lineupName)
	    lineupsC.append(provider.get('headendId'))
	    deviceGet = provider.get('device')
	    if deviceGet == '' or deviceGet == ' ':
		deviceGet = '-'
	    deviceX.append(deviceGet)
    else:
	print 'Error - No Providers!', 'No providers were found - please check zipcode and try again.'
	return

    # Choose lineup
    print '  ' + lineupsN[0]
    for i in range(1,len(lineupsN)):
	print i, lineupsN[i]
    sys.stdout.write( 'Select one: ' )
    sys.stdout.flush()
    lineupSel = sys.stdin.readline().strip()
    if ( lineupSel.isdigit() ):
	lineupSel = int(lineupSel)
    else:
	print 'No lineup selected'
	return
    lineupcode = lineupsC[lineupSel]
    lineupname = lineupsN[lineupSel]
    device = deviceX[lineupSel]

    # Create channel list
    gridtime = (int(time.mktime(time.strptime(str(datetime.datetime.now().replace(microsecond=0,second=0,minute=0)), '%Y-%m-%d %H:%M:%S'))))
    url = 'http://tvlistings.gracenote.com/api/grid?lineupId=&timespan=3&headendId=' + lineupcode + '&country=' + country + '&device=' + device + '&postalCode=' + zipcode + '&time=' + str(gridtime) + '&pref=-&userId=-'
    content = urllib2.urlopen(url).read()
    contentDict = json.loads(content)
    stationDict = {}
    if 'channels' in contentDict:
	for channel in contentDict['channels']:
	    skey = channel.get('channelId')
	    stationDict[skey] = {}
	    stationDict[skey]['name'] = channel.get('callSign')
	    stationDict[skey]['num'] = channel.get('channelNo')
	    stationDict[skey]['include'] = 'False'
    stationDictSort = OrderedDict(sorted(stationDict.iteritems(), key=lambda i: (float(i[1]['num']))))

    # Select channels
    print 'Select stations: '
    ans = ''
    for station in stationDictSort:
	if ( ans == 'all' ):
	    stationDictSort[station]['include'] = 'True'
	elif ( ans == 'none' ):
	    stationDictSort[station]['include'] = 'False'
	else:
	    sys.stdout.write( stationDictSort[station]['name'] + ' (' + stationDictSort[station]['num'] + ')  [yes,no,all,none (default=no)]: ' )
	    sys.stdout.flush()
	    ans = sys.stdin.readline().strip()
	    ans = ans.lower()
	    if (( ans == 'yes' ) or ( ans[0] == 'y' ) or ( ans == 'all' )):
		stationDictSort[station]['include'] = 'True'
	    else:
		stationDictSort[station]['include'] = 'False'

    # Flush old cache
    if os.path.exists(cacheDir):
	entries = os.listdir(cacheDir)
	for entry in entries:
	    oldfile = entry.split('.')[0]
	    if oldfile.isdigit():
		fn = os.path.join(cacheDir, entry)
		try:
		    os.remove(fn)
		except:
		    pass

    # Write the config file
    with open(filename,'w') as f:
	f.write('country={}\n'.format(country))
	f.write('zipcode={}\n'.format(zipcode))
	f.write('lineupcode={}\n'.format(lineupcode))
	f.write('lineup={}\n'.format(lineupname))
	f.write('device={}\n'.format(device))
	# Need configuration prompts
	f.write('chmatch=true\n')
	f.write('epgenre=3\n')
	f.write('epicon=1\n')
	f.write('xdetails=true\n')
	f.write('xdesc=false,10,13,6,18,6,15,2,9,2,14,6,11,6,12,6,20,6,19,0,0\n')
	# Dump channel list
	for station in stationDictSort:
	    if ( stationDictSort[station]['include'] == 'True' ):
		f.write('channel={}.zap2epg\n'.format(station))
	    else:
		f.write('channel!{}.zap2epg\n'.format(station))

# Main routine
def tv_grab_na_zap():
    # Setup command line arguments
    ap = argparse.ArgumentParser()

    # All (help handled by ArgumentParser)
    ap.add_argument("--version", help="display grabber version", action="store_true")
    ap.add_argument("--capabilities", help="list grabber capabilities", action="store_true")
    ap.add_argument("--description", help="prints a description that identifies the grabber", action="store_true")

    # Baseline
    ap.add_argument("--days", help="number of days of listings", type=int, default=7)
    ap.add_argument("--offset", help="number of days to skip before listings start", type=int, default=0)
    ap.add_argument("--quiet", help="turns off all informational messages", action="store_true")
    ap.add_argument("--output", help="output file for XML tv listings")
    ap.add_argument("--debug", help="turns on debug messages", action="store_true")
    ap.add_argument("--config-file", help="configuration file", default=os.path.join(userdata, 'tv_grab_na_zap.conf'))

    # Manual Config
    ap.add_argument("--configure", help="manual configuration", action="store_true")

    # Parse command line
    args = ap.parse_args()

    # Boilerplate
    if ( args.version ):
	print "tv_grab_na_zap v0.1"
	exit(0)
    if ( args.capabilities ):
	print "baseline"
	print "manualconfig"
	exit(0)
    if ( args.description ):
	print "NA Zap2it (www.zap2it.com)"
	exit(0)

    # Global
    if ( args.quiet == True ):
	verbose = False

    # (Re)configuration
    if ( args.configure ):
	configure(args.config_file)
	exit(0)

    # Limit to two weeks
    if ( args.offset > 14 ):
	sys.stderr.write("No data available\n")
	exit(1)

    # Call main routine
    mainRun( args.days, args.offset, args.config_file, args.output )

    # Copy file for debug
    #cfgname = os.path.splitext(os.path.basename( args.config_file ))[0]
    #dbgfile = os.path.join( userdata, cfgname + '_' + str(args.offset) + '_' + str(args.days) + ".xml" )
    #copyfile( args.output, dbgfile )

    exit(0)

# If run from command line
if __name__ == '__main__':
    # Init
    verbose = True

    # Setup directorys
    userdata = appdirs.user_data_dir('tv_grab_na_zap', 'crwolff')
    mkdir_p(userdata)
    cacheDir = os.path.join(userdata, 'cache')

    # Enable logging
    log = os.path.join(userdata, 'zap2epg.log')
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.handlers.RotatingFileHandler( log, maxBytes=5*1024*1024, backupCount=5)
    fmt = logging.Formatter( '%(asctime)s %(message)s', datefmt='%Y/%m/%d %H:%M:%S' )
    handler.setFormatter( fmt )
    logger.addHandler(handler)

    # Parse command line
    tv_grab_na_zap()
